% Impala Operating System
%
% Copyright (C) 2009 University of Wroclaw. Department of Computer Science
%    http://www.ii.uni.wroc.pl/
% Copyright (C) 2009 Mateusz Kocielski, Artur Koninski, Pawel Wieczorek
%    http://trzask.codepainters.com/impala/trac/
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
% 1. Redistributions of source code must retain the above copyright
%  notice, this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%  notice, this list of conditions and the following disclaimer in the
%  documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
% FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
% DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
% OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
% HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
% OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
% SUCH DAMAGE.
%
% $Id$

\section{Wielozadaniowo¶æ.}

Zadania procesora s± reprezentowane przez w±tki (\texttt{thread\_t}). Ka¿dy
z~w±tków dostaje kwant czasu na~wykorzystanie procesora, dziêki czemu
u¿ytkownik mo¿e odnie¶æ wra¿enie, ¿e uruchomione przez niego zadania dzia³aj±
jednocze¶nie. Za przydzia³ czasu procesora jest odpowiedzialny program
planisty omówiony w \ref{SCHEDULER}.

W±tek posiada w~sobie miêdzy innymi nastêpuj±ce informacje:
\begin{itemize}
 \item kontekst, s³u¿±cy do~zachowywania jego stanu
 \item proces do, którego przynale¿y w±tek
 \item adres procedury wej¶ciowej, od~której rozpoczyna siê dzia³anie zadania
 \item adres stosu u¿ytkownika i jego rozmiar
 \item adres stosu alternatywnego i jego rozmiar
 \item przestrzeñ adresowa, w której dzia³a to~zadanie (wspólna dla wszystkich
    w±tków w obrêbie tego samego procesu)
\end{itemize}

W±tki procesora wykonuj±ce kod u¿ytkownika potrzebuj± dwóch stosów.
Pierwszy stos jest przeznaczony do~standardowego u¿ytku. Stos
alternatywny natomiast jest wykorzystywany wtedy, kiedy procesor wyw³aszcza
zadanie
obs³uguj±c przerwanie. W±tki wykonuj±ce kod systemu uto¿samiaj± ze~sob±
te~dwa stosy.

Stosy u¿ytkownika s± jego prywatnymi stosami, tzn. istniej±cymi jedynie
w~jego przestrzeni adresowej, natomiast stosy alternatywne znajduj± siê
w~przestrzeni j±dra, dziêki czemu s± zawsze dostêpne dla systemu.

Adres procedury wej¶ciowej jest wykorzystywany je¿eli dany w±tek nie mia³
dot±d ani razu przydzielonego czasu procesora - np. zosta³ dopiero utworzony.
W takim przypadku jego dzia³anie rozpoczyna siê od~adresu procedury wej¶ciowej,
w~przeciwnym od~adresu zapisanego w~kontek¶cie.

Kontekst procesora zawiera w~sobie takie informacje jak ramka przerwania,
któr± zapisuje procesor na~stos alternatywny przy wyw³aszczeniu przez
przerwanie oraz pomocniczy schowek na~rejestry procesora.

\subsection{Zmienianie kontekstu procesora.}

Mechanizm zmiany kontekstu procesora jest oparty o~mechanizm obs³ugi przerwañ
przez procesor. Przed rozpoczêciem omawiania mechanizmu zmian kontekstu
wyszczególnimy kilka faktów, zwi±zanych z~prac± procesora.
\begin{itemize}
 \item Procesor podczas wywo³ywania procedury k³adzie na~stos adres
       aktualnie wykonywanej instrukcji, tak aby po zakoñczeniu procedury
       móg³ wróciæ do~kodu j± wywo³uj±cego, zapisane w ten sposób
       adresy na~stosie tworz± ,,¶lad wywo³añ''.
 \item Stos w procesorze jest definiowany przez adres w~rejestrze
       \texttt{esp}, a operacje na~stosie pobieraj± i~zapisuj± dane
       pod tym adresem odpowiednio go modyfikuj±c.
\end{itemize}


Pod obs³ugê zegara systemowego, którego przerwanie jest generowane~z
czêstotliwo¶ci± 100Hz, jest podpiêty program planisty, który je¿eli zdecyduje
siê zmieniæ kontekst procesora, tzn. wykonywany przez procesor w±tek,
to~przekazuje sterownie do~procedury \texttt{thread\_switch} przekazuj±c jej
deskryptor aktualnie wykonywanego w±tku (\texttt{curthread}) oraz w±tku
na~jaki ma~nast±piæ zmiana.

Wspomniana procedura zapisuje aktualne rejestry procesora do~pomocniczego
schowka w~kontek¶cie w~deskryptorze aktualnie wykonywanego w±tku, a~nastêpnie 
wczytuje zachowane wcze¶niej rejestry ze schowka drugiego w±tku.

Poniewa¿ w~rejestrach procesora s± zapisane adresy lokalizuj±ce stos
to powy¿sza operacja powoduje ,,podmianê'' aktualnie wykonywanego stosu
procesora na ten, jaki by³ w momeñcie zapisywania rejestrów drugiego w±tku
(to znaczy dok³adnie wtedy, kiedy planista uruchomi³ \texttt{thread\_switch}
podczas pracy drugiego w±tku). Poniewa¿ na~stosie jest zapisany ¶lad
wywo³añ, to po podmianie stosu procesor zachowa siê dok³adnie tak, jak by siê
zachowa³ wykonuj±c drugi w±tek po~zachowaniu jego rejestrów. Bardzo podobny
mechanizm istnieje w~jêzyku C w~procedurach \texttt{setjmp} i \texttt{longjmp}.
Koñcz±c po kolei procedury procesor wróci do~tej, któr± wywo³a³ procesor
do~obs³ugi przerwania zegara podczas pracy drugiego w±tku, a jej
zakoñczenie przywróci stan procesora z~zachowanej ramki przerwania,
zawieraj±cej stan drugiego w±tku. Ta operacja jest prawid³owa, poniewa¿
ramki przerwañ s± zapisywane na~stosach alternatywnych, które s± dostêpne
w~przestrzeni j±dra.

Je¿eli drugi w±tek nie mia³ dot±d przydzielonego czasu procesora,
to~procedura zmiany kontekstu nie mia³a okazji zachowaæ jego
rejestrów w~schowku, a procesor zapisaæ ramkê przerwania na~jego stosie
alternatywnym. W takim wypadku uruchamiana jest procedura
\texttt{thread\_resume}, która rêcznie buduje ramkê stosu, aby oszukaæ
procesor, ¿e powraca do~obs³ugi zadania, które wcze¶niej wyw³asczy³.
Jako adres wyw³aszczonej instrukcji jest podawana procedura wej¶ciowa.

W schowku na~rejestry procesora jest zapisywany równie¿ rejestr kontrolny
procesora \texttt{cr3} zawieraj±cy adres katalogu stron, tak wiêc wczytuj±c
adresy z~tego schowka nastêpuje równie¿ podmiana wirtualnej przestrzeni
adresowej u¿ytkownika.

\subsection{Rozwidlanie procesów.}

Jedyn± drog± stworzenia nowego procesu w~systemie UNIX jest rozwidlenie
istniej±cego procesu. Zgodnie z~semantyk± nadan± przez standard nowy proces
dziedziczy po~rodzicu kopiê jego deskryptorów plików, przestrzeni adresowej
oraz ¶rodowiska.

Je¿eli w~procesie rodzica dzia³a³o wiele w±tków to~nowy zawiera tylko jeden,
który jest kopi± w±tku zlecaj±cego systemowi zadanie rozwidlenia.

Za~obs³ugê rozwidlenia odpowiedzialna jest procedura \texttt{proc\_fork}.
Po stworzeniu nowego w±tku w~systemie kopiowany jest stos alternatywny
oraz kontekst w±tku~wywo³uj±cego. Skopiowany stos zawiera ramkê przerwania
z~zachowanym stanem w±tku wywo³uj±cego, co umo¿liwia oszukania procesora
w~podobny sposób jak w~procedurze \texttt{thread\_resume} i~uruchomienie
nowy w±tek z~porz±danym stanem.

\subsection{Synchronizacja.}

Wa¿nym elementem implementacji mechanizmów synchornizacji s± niepodzielne
instrukcje procesora, tzn takie których nie mo¿na wyw³aszczyæ w~trakcie
ich wykonywania. Instrukcje porównania oraz~zapisu generowane przez kompilator
spe³niaj± tê w³a¶ciwo¶æ. Modu³ obs³ugi platformy
sprzêtowej musi dostarczyæ jeszcze procedurê \texttt{atomic\_change\_int}
modyfikuj±c± komórkê pamiêci i~zwracaj±c± jej star± warto¶æ w~sposób
niepodzielny. Gdyby procedura nie spe³nia³a ¿±danej warto¶ci,
to pomiêdzy pobraniem starej warto¶ci, a zapisaniem nowej mog³oby zostaæ
wykonane wyw³aszczenie, podczas którego warto¶æ komórki pamiêci zosta³a
zmodyfikowana. W takim wypadku wszelkie decyzje podjête na~podstawie
starej warto¶ci, zwróconej przez procedurê, mog³yby byæ b³êdne.

Najprotszym mechanizmem synchronizacji s± wiruj±ce zamki, wykorzystuj±ce
wprost niepodzielne instrukcje procesora. Taki zamek jest opisywany przez
jedn± komórkê pamiêci przyjmuj±c± warto¶c \texttt{SPINLOCK\_LOCK}
lub~\texttt{SPINLOCK\_UNLOCK} odpowiednio do~stanu blokady. 

Operacja zamkniêcia u¿ywa wspomnianej wcze¶niej procedury aby ustawiæ
stan blokady na~\texttt{SPINLOCK\_LOCK}. Je¿eli stara warto¶æ komórki
pamiêci by³a równa \texttt{SPINLOCK\_UNLOCK} to~z~niepodzielno¶ci u¿ytej procedury
wynika, ¿e nikt inny nie móg³ odczytaæ ani zmodyfikowaæ jej warto¶ci i~uda³o
siê pomy¶lnie zmieniæ stan blokady.
Je¿eli stara warto¶c komórki pamiêci by³a równa \texttt{SPINLOCK\_LOCK},
to równiez z~niepodzielno¶æi tej procedury wynika, to ¿e blokada zosta³a
zamkniêta przez kogo¶ innego. W takim~wypadku procedura zamkniêcia zamka
krêci siê wkó³ko (wiruje), dopóki nie uda siê jej zamkn±æ blokady.

Ten sposób synchronizacji nie zapewnia, ¿e w±tki nie bêd± g³odzone (oczekiwaæ
w~nieskoñczono¶æ), dodatkowo oczekiwanie na~zwolnienie blokdy jest aktywne
co marnuje czas pracy procesora.

Innym rodzajem blokady s± zamki \texttt{mutex\_t} (\emph{mutual exclue}),
których klienci s± usypiani na~czas za³o¿onej blokady. Zamki wewnêtrznie
u¿ywaj± kolejki FIFO do~kontrolowania kolejno¶ci budzenia w±tków, chc±cych
wej¶æ do chronionej sekcji krytycznej - ta strategia eliminuje problem
g³odzenia. Wewnêtrzna sturktura danych tej blokady jest chroniona za~pomoc± wiruj±cych
zamków.

\label{pthread_condvar}
Zmienna warunkowa jest~mechanizmem ¶cisle powi±zanym z~mechanizmem blokad.
Jej zadanie to umo¿liwienie biernego oczekiwania na~zdarzenie.
Jest on sprzê¿ony z~wybran± blokad± w~celu wykonywania niepodzielnej operacji
jej zwolnienia oraz u¶pienia w±tku.

Mechanizm jest standardowo wykorzystywany do~implementacji kolejek, sama
blokada mo¿e jedynie chroniæ sekcje krytyczne procedur wys³ania i odebrania
wiadomo¶ci do kolejki, lecz uniemo¿liwia oczekiwanie w~przypadku braku
wiadomo¶æi do odebrania. Mechanizm wykorzystuje siê tak, ¿e gdy nie ma
wiadomo¶æi do~odebrania to klient jest usypiany, a blokada zwalaniana.
Dziêki niepodzielno¶æi nie jest mo¿liwa sytuacja, gdy pomiêdzy u¶pieniem
a zwolnieniem blokady kto¶ dostarczy wiadomo¶æ do kolejki.

Dostarczenie zdarzenia budz±cego jest mo¿liwe do~jednego w±tku lub
do~wszystkich naraz,  mo¿e je dostarczyæ jedynie w³a¶ciciel blokady sprzê¿±nej
z~zmienn± warunkow±. Zdarzenie jest dostarczane przy wyj¶ciu z~sekcji
krytycznej przez klienta je zg³aszaj±cego. Budzony w±tek dostaje od~razu
zamkniêty zamek, dziêki czemu powraca on do~swojej sekcji krytycznej.


Nasza implementacja zamków \texttt{mutex\_t} implemente

\subsection{Szeregowanie zadañ.} \label{SCHEDULER}

Zaimplementowany w systemie algorytm szeregowania zadañ zosta³ oparty na
algorytmach planistów zastosowanych w systemach 4.3BSD oraz SVR4. Dok³adny 
opis tych
algorytmów znajduje siê w~\cite{unixjadro}. 

Omówimy tutaj jedynie ogólny zarys planisty oraz ró¿nice w stosunku do pierwowzoru. 
Planista przydziela procesom priorytet na podstawie ich ostatniego zachowania w systemie 
(tzn. zu¿ycia czasu procesora oraz innych statystyk) oraz poziomu uprzejmo¶ci (nice).
Priorytet jest liczb± z~zakresu od~$0$ do~$127$, procesy o~mniejszej warto¶ci
priorytetu s± traktowane jako wa¿niejsze, mo¿na wiêc rozumieæ tê warto¶æ jako
karê nak³adan± na~proces. Wszystkie w±tki w ramach procesu traktowane s±
jednakowo i~wszystkie posiadaj± priorytet równy priorytetowi procesu. Przestrzeñ
priorytetów podzielona jest na~$32$ grupy po~$4$ warto¶ci w ka¿dej grupie,
kolejka $Q_i$ odpowiada za~zbiór priorytetów $i,i+1,i+2,i+3$.
Procesy przynale¿± do odpowiednich kolejek, za rozsiewanie ich odpowiada
okresowo (co \texttt{SCHED\_RESCHEDULE} kwantów czasu) uruchamiana funkcja 
\texttt{\_\_resched}, która dokonuje podzia³u na podstawie listy \texttt{run\_queue}, 
w której znajduj± siê w±tki gotowe do uruchomienia, po~wykonaniu tej funkcji 
nastêpuje wybranie niepustej
kolejki zawieraj±cej najni¿sze priorytety i~w ramach tej kolejki planista
realizuje podej¶cie zwane algorytmem karuzelowym. Algorytm karuzelowy jest
prostym sposobem szeregowania zadañ polegaj±cym na organizacji procesów w listê
cykliczn±, a nastêpnie przydzielanie ka¿demu z w±tków kolejno jednakowego kwantu
czasu. Procesy znajduj±ce siê poza t± kolejk± nie s±
brane pod uwagê a¿ do~nastêpnego wywo³ania funkcji \texttt{\_\_resched}, która
realizuje tak¿e uaktualnianie priorytetu procesów wg. wzoru:
\[ \mbox{priorytet} = 2\cdot\mbox{poziom\_uprzejmosci} 
    + \mbox{wykorzystanie\_procesora}/2 \]
Wszystkie opisywane przez wzór warto¶ci przechowywane s± w bloku kontrolnym
procesu.
 Algorytm umo¿liwia preferowanie pewnych zadañ przez u¿ytkownika systemu za~pomoc± poziomu
uprzejmo¶ci, oraz uwzglêdnia wykorzystanie procesora przez poszczególne procesy, co umo¿liwia
wybór zadañ interakcyjnych (tj. edytory tekstu) przed zadaniami obliczeniowymi
(tj. kompilatory). 
