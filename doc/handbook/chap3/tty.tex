% Impala Operating System
%
% Copyright (C) 2009 University of Wroclaw. Department of Computer Science
%    http://www.ii.uni.wroc.pl/
% Copyright (C) 2009 Mateusz Kocielski, Artur Koninski, Pawel Wieczorek
%    http://bitbucket.org/wieczyk/impala/
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
% 1. Redistributions of source code must retain the above copyright
%  notice, this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%  notice, this list of conditions and the following disclaimer in the
%  documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
% FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
% DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
% OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
% HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
% OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
% SUCH DAMAGE.
%
% $Id: vfs.tex 486 2009-06-25 07:51:47Z wieczyk $

\section{Interfejs terminali.}
\label{TTY}
Programy u¿ytkownika wymagaj± od systemu ujednoliconego dostêpu do urz±dzeñ
umo¿liwiaj±cych im komunikacjê z u¿ytkownikiem. Urz±dzenia s³u¿±ce do takiej
komunikacji nazywamy terminalami. Terminale mo¿na podzieliæ na nastêpuj±ce grupy:
\begin{enumerate}
\item Terminal zewnêtrzny, komunikuj±cy siê z komputerem poprzez port szeregowy
b±d¼ modem
\item Terminal zintegrowany z komputerem, komunikacja nastêpuje np. poprzez
dzielon± pamiêæ. (Klawiatura, monitor)
\item Terminal sieciowy - komunikacja np. poprzez Ethernet
\end{enumerate}
Wszystkie te urz±dzenia widoczne s± dla u¿ytkownika w ujednoliconej formie - jako
urz±dzenia terminalowe. W systemie Impala z terminalami zwi±zana jest struktura
\texttt{tty\_t}. Rejestrowanie nowego urz±dzenia terminalowego w systemie
nastêpuje poprzez funkcjê \texttt{tty\_create}. Jako argumenty przyjmuje ona
nazwê nowego urz±dzenia, dowoln± strukturê z prywatnymi danymi urz±dzenia, oraz
wska¼nik do funkcji obs³uguj±cej zapis na tym urz±dzeniu. W ten sposób, system
terminali stanowi nak³adkê na inne urz±dzenia, implementuj±c± ich typowe
funkcjonalno¶ci w zunifikowany sposób.
\subsection{Re¿im linii.}
Aby zapewniæ zgodno¶æ programów Unixowych z oferowanym przez nas interfejsem
terminali, zosta³ on zaprojektowany zgodnie ze standardem POSIX dotycz±cym tej
kwestii. Standard reguluje jak ma przebiegaæ wej¶cie, wyj¶cie oraz zmiana
ustawieñ terminala.
\subsubsection{Zmiana ustawieñ.}
Najwa¿niejsze ustawienia terminala przechowywane s± w strukturze \texttt{termios}.
Zawiera ona nastêpuj±ce pola:

\begin{center}
\begin{tabular}{|l|l|}
\hline
tcflag\_t c\_iflag & Flagi konfiguruj±ce zachowanie wej¶cia\\
tcflag\_t c\_oflag & Flagi konfiguruj±ce zachowanie wyj¶cia\\
tcflag\_t c\_lflag & Ogólne flagi ustawiaj±ce tryb pracy terminala\\
tcflag\_t c\_cflag & Flagi zwi±zane z obs³ug± po³±czenia\\
cc\_t c\_cc[NCCS] & Znaki specjalne \\
\hline
\end{tabular}
\end{center}

Przeznaczenie poszczególnych pól zostanie przybli¿one w kolejnych podrozdzia³ach.
Biblioteka C udostêpnia funkcje do zapisu i odczytu aktualnych ustawieñ terminala
- s± to odpowiednio \texttt{tcsetattr} i \texttt{tcgetattr}. Funkcje to zosta³y
zaimplementowane w oparciu o wywo³anie systemowe \texttt{ioctl}.
\subsubsection{Otwieranie terminala, uprawnienia procesów.}
Terminal otwierany jest jak zwyk³y plik, przy pomocy wywo³ania systemowego
\texttt{open}. Aby umo¿liwiæ wielu programom jednoczesne korzystanie z jednego
terminala, oraz umo¿liwiæ kontrolê zadañ w pow³okach takich jak \texttt{ash},
wprowadzona zosta³a dodatkowa organizacja procesów.

Ka¿dy proces mo¿e posiadaæ swój powi±zany terminal kontroluj±cy. Ogólnie rzecz
bior±c, mo¿e on korzystaæ tylko z tego terminala.
Procesy zosta³y podzielone na sesje, oraz w ramach sesji na grupy.
Wszystkie procesy w ramach sesji, które maj± ustawiony terminal kontroluj±cy,
maj± ustawiony ten sam terminal. Tak wiêc terminal jest powi±zany z sesj±.
Terminal mo¿e byæ zwi±zany z tylko jedn± sesj± i vice versa.

W ramach sesji procesy tworz± roz³±czne grupy, z których jedna mo¿e byæ
wyszczególniona jako grupa procesów pierwszoplanowych terminala. Procesy z tej
grupy jako jedyne maj± dostêp do wej¶cia z terminala. Co do zapisu na terminal,
mo¿liwy jest on tak¿e spoza grupy procesów pierwszoplanowych, jednak to wymaga
dodatkowych ¶rodków (w postaci blokowania lub ignorowania sygna³u \texttt{SIGTTOU}).

Sesja oraz grupa procesów posiadaj± swój identyfikator, równy identyfikatorowi
procesu, który jako pierwszy do danego bytu nale¿a³.
Proces taki zwany jest odpowiednio liderem sesji i liderem grupy.
Do tworzenia nowej sesji wykorzystuje siê funkcjê \texttt{setsid}.
Terminal kontroluj±cy procesu ustawiany jest automatycznie, w momencie
otwierania go, o ile proces otwieraj±cy nie posiada ju¿ terminala kontroluj±cego,
jest liderem sesji, oraz terminal ten nie jest jeszcze zwi±zany z ¿adn± sesj±.
Terminal kontroluj±cy, sesjê, oraz grupê proces dziedziczy po ojcu w wywo³aniu
\texttt{fork}.

Pobieranie i modyfikacja grupy procesu realizowane s± poprzez \texttt{getpgid}
i \texttt{setpgid}. Wybór grupy procesów pierwszoplanowych terminalu nastêpuje
poprzez wywo³anie \texttt{ioctl} na deskryptorze pliku terminala, z poleceniem
\texttt{TIOCSPGRP} (zobacz tak¿e \texttt{tcsetpgrp} i \texttt{tcgetpgrp}).
\subsubsection{Zapisywanie do terminala.}
% Mo¿na wywaliæ / skróciæ, w zwi±zku z powielaniem tre¶ci ju¿ opisanych
Programy przekazuj± dane na wyj¶cie terminala za pomoc± jednej z funkcji biblioteki C,
zazwyczaj z rodziny \texttt{printf}.
Funkcja \texttt{printf} wywo³uje poprzez przerwanie systemow± funkcjê \texttt{sc\_write}.
Ta z koleji, poprzez vnode zwi±zany z deskryptorem pliku przekazuje bufor z danymi
u¿ytkownika do funkcji obs³ugi \texttt{tty\_write} urz±dzenia znakowego zwi±zanego z terminalem.

Zanim bêdzie móg³ nast±piæ faktyczny zapis danych przy pomocy funkcji zarejestrowanej
w procedurze \texttt{tty\_create}, funkcja \texttt{tty\_write} weryfikuje, czy
pisz±cy proces ma do tego prawo, oraz w zale¿no¶ci od ustawieñ wykonuje koñcowe
przekszta³cenia na danych u¿ytkownika. Wykonywane przekszta³cenia uzale¿nione s±
od warto¶ci \texttt{c\_oflag}. Mo¿liwe operacje to miedzy innymi zamiana znaków
\texttt{CR} (powrót karetki) na znaki \texttt{NL} (nowej linii) i zamiana znaków
\texttt{NL} na parê \texttt{CR-NL}.

\subsubsection{Odczyt z terminala.}
Urz±dzenie wej¶ciowe otrzymawszy dane, przekazuje je do bufora powi±zanego terminala
poprzez funkcjê \texttt{tty\_input}. U¿ytkownik uzyskuje dostêp do tych danych
przy pomocy funkcji bibliotecznych takich jak \texttt{scanf}, korzystaj±cych z wywo³ania
systemowego \texttt{read}. Dane uzyskane w ten sposób to ci±g znaków ASCII.

Wyobra¼my sobie nastêpuj±c± sytuacjê: program pyta u¿ytkownika, o podanie imienia,
ten jednak, w po³owie wpisywanego tekstu pope³ni³ b³±d i skorygowa³ go przy u¿yciu
klawisza backspace. Program jest zainteresowany jedynie poprawionym wpisem, a nie
ci±giem znaków zawieraj±cych b³êdne dane oraz kod ASCII klawisza backspace.
Jest to na tyle czêsta sytuacja, ¿e schemat obs³ugi wej¶cia, w którym sterownik
dba o obs³ugê zmian w ramach jednej lini wej¶cia zosta³ uwzglêdniony w standardzie
POSIX jako element interfejsu terminali. Oczywi¶cie niektóre programy chc±
znaæ kody wszystkich naciskanych klawiszy, bez konieczno¶ci czekania na znak
nowej lini, tak wiêc i ta sytuacja musi byæ obs³ugiwana. Pierwszy tryb wed³ug
POSIX zwiemy trybem kanoniczym, drugi surowym. Tryb pracy terminala uzale¿niony jest od
obecno¶ci flagi \texttt{ICANON} w polu \texttt{c\_lflag} struktury opisuj±cej
konfiguracjê terminala.
\subsubsection{Tryb kanoniczny.}
Domy¶lnie terminal znajduje siê w trybie kanonicznym.
W trybie tym rozpoznawane s± znaki specjalne, ustalone w polach tabeli
\texttt{c\_cc}. Nale¿± do nich EOF, EOL, ERASE, INTR, KILL, QUIT, START, STOP,
SUSP i TIME. Sterownik dokonuje edycji linii w przypadku rozpoznania znaku ERASE
(usuniêcie ostatniego znaku) b±d¼ KILL (usuniêcie ca³ej lini). Je¿eli pole
\texttt{c\_lflag} zawiera flagê \texttt{ISIG}, wyst±pienie znaków INTR, QUIT
oraz SUSP powoduje wys³anie do grupy procesów pierwszoplanowych odpowiednio
sygna³u \texttt{SIGINT}, \texttt{SIGQUIT}, \texttt{SIGTSTP}.

Procedura \texttt{read} zwraca wynik, tylko w przypadku gdy
w buforze wej¶ciowym terminala istnieje linia zakoñczona znakiem NL, EOF b±d¼ EOL.
Je¿eli linia nie jest jeszcze gotowa, proces zasypia w oczekiwaniu na ni±.
Zwrócony bufor zawiera co najwy¿ej jedn± liniê z wej¶cia.

W trybie kanonicznym na wej¶ciu wykonywane jest wstêpne przetwarzanie,
wed³ug warto¶ci \texttt{c\_iflag}. Mo¿liwe operacje to m.in. ignorowanie znaków
\texttt{CR}, zamiana znaku \texttt{CR} na znak \texttt{NL} i na odwrót.
\subsubsection{Tryb surowy.}
W trybie surowym znaki nie s± dodatkowo przetwarzane. Poprzez ustawienie pól
\texttt{c\_cc[VMIN]} i \texttt{c\_cc[VTIME]} u¿ytkownik mo¿e kontrolowaæ
minimaln± ilo¶æ znaków, jaka zostanie zwrócona przez \texttt{read}, oraz czas,
jaki procedura ma czekaæ na kolejny znak (b±d¼ ca³o¶æ wej¶cia - przy \texttt{MIN}$=0$).
\subsection{Konsola.}
Jedynym w tej chwili zaimplementowanym w Impali terminalem jest konsola - zestaw
z³o¿ony z klawiatury i wy¶wietlacza pod³±czonego do karty graficznej.
Urz±dzenia te s± widoczne w systemie jako kilka osobnych wirtualnych konsoli,
o plikach \texttt{/dev/ttyvX}, gdzie \texttt{X} jest numerem urz±dzenia.
Prze³±czanie pomiêdzy tymi konsolami nastêpuje po naci¶niêciu odpowiedniego
klawisza funkcyjnego \texttt{Fx}.
\subsubsection{Obs³uga klawiatury.}
Niskopoziomowa obs³uga klawiatury przebiega nastêpuj±co:
\begin{itemize}
\item Ka¿de wci¶niêcie i zwolnienie klawisza powoduje wygenerowanie przerwania
klawiatury.
\item Procedura obs³ugi tego przerwania rozpoznaje rodzaj zdarzenia,
odczytuj±c jego kod - "scancode" - z odpowiedniego portu uk³adu kontrolera
klawiatury (i8042).
\item Na podstawie scancode wyznaczany jest unikalny kod klawisza - "keycode".
\item Na podstawie kodu klawisza, przechowywanych w sterowniku informacji
o naci¶niêtych klawiszach specjalnych takich jak shift, alt i ctrl
oraz "keymapy" odwzorowuj±cej te informacje w znak (ewentualnie ci±g znaków)
ASCII, wyznaczany jest wynik naci¶niêcia klawisza w postaci, jakiej oczekuje
u¿ytkownik.
\item Wynik z poprzedniego kroku przekazywany jest do aktywnej wirtualnej
konsoli oraz powi±zanego z ni± terminala poprzez procedurê
\texttt{vcons\_input\_[char/string]}.
\end{itemize}
\subsubsection{Obs³uga karty graficznej.}
Niskopoziomowa komunikacja z kart± graficzn± w Impali polega na:
\begin{itemize}
\item Pocz±tkowym zainicjalizowaniu karty graficznej, realizowanym poprzez
odpowiedni± sekwencjê zapisów i odczytów z portów karty. W kroku tym
ustawiany jest m.in. kursor sprzêtowy. Poniewa¿ nie ma mo¿liwo¶ci wy³±czenia
migania kursora sprzêtowego, zostaje on ukryty. Kursor widoczny na ekranie jest
emulowany programowo.
\item Bufor ramki karty graficznej jest odwzorowany w pamiêæ pod adresem fizycznym\\
\texttt{0xb8000}. Jako, ¿e w Impali niskie adresy s± zarezerwowane na przestrzeñ
u¿ytkownika, ten adres fizyczny jest z koleji odwzorowywany w stercie j±dra.
Wy¶wietlenie znaku w pewnym miejscu ekranu polega na
zapisaniu go w odpowiednim miejscu pamiêci. Atrybuty znaków takie jak ich kolor
dla znaku z komórki pamiêci $x$ ustawiane s± w komórce $x+1$.
\end{itemize}
\subsection{Emulacja terminala.}
Aby umo¿liwiæ programom u¿ytkownika bardziej zaawansowan± kontrolê nad
zawarto¶ci± ekranu, wirtualne konsole udaj±, ¿e s± fizycznym terminalem.
Konsola w Impali emuluje VT100, popularny terminal stworzony przez
firmê Digital Equipment Corporation. Emulacja ta polega na rozpoznawaniu
sekwencji steruj±cych tego terminala oraz odpowiednim reagowaniu na nie.
Podobnie, wej¶cie z klawiatury przedstawiane jest u¿ytkownikowi w postaci, jak±
by otrzyma³ pracuj±c na terminalu VT100 i korzystaj±c z jego klawiatury.

Dziêki takim dzia³aniom progamy maj± mo¿liwo¶æ m.in. ustawiaæ pozycjê kursora
na ekranie, przewijaæ ekran, kasowaæ jego zawarto¶æ, pobieraæ informacje
o po³o¿eniu kursora i o wspieranych funkcjonalno¶ciach, zmieniaæ tryb pracy
terminala i atrybuty wypisywanych znaków.
\begin{table}
\begin{tabular}{|l|l|}
\hline
ESC[2J & Czy¶ci ca³y ekran \\
ESC3C & Przesuwa kursor o 3 pozycje w prawo \\
ESC[1;5H & Ustawia kursor w pi±tej kolumnie pierwszego wiersza \\
ESC[5;7;1m & W³±cza mruganie, pogrubienie oraz zamienia kolor t³a z kolorem znaku \\
ESC[6n & ¯±da informacji o aktualnym po³o¿eniu kursora \\
\hline
\end{tabular}
\caption{Przyk³adowe sekwencje steruj±ce VT100. ESC oznacza znak \texttt{$\backslash$033}}
\end{table}

%mo¿na daæ ma³± tabelkê z przyk³adowymi sekwencjami
\subsection{Termcap.}
Jako, ¿e istnieje wiele terminali, ró¿ni±cych siê sekwencjami
steruj±cymi, rozmiarem ekranu i innymi szczegó³ami ich dzia³ania, wynik³a
potrzeba udostêpniania procesowi informacji o terminalu na jakim aktualnie
dzia³a. Identyfikator tego terminala przechowywany jest w zmiennej ¶rodowiskowej
\texttt{TERM}. Dostêp do informacji o konkretnych sekwencjach steruj±cych
mo¿liwy jest poprzez nastêpuj±ce funkcje biblioteki C: \texttt{tgetstr},
\texttt{tgetnum}, \texttt{tgetflag}. Zanim jednak bêdziemy mogli skorzystaæ
z tych funkcji, konieczne jest za³adowanie informacje o wybranym terminalu
za pomoc± funkcji \texttt{tgetent}. Informacje uzyskane z wymienionych funkcji
mog± s³u¿yæ jako wej¶cie do procedury \texttt{tgoto}, wype³niaj±cej sekwencjê
steruj±c± o wymagane argumenty, oraz procedury \texttt{tputs} wysy³aj±cej
sekwencjê do terminala.

Baza danych dla termcap typowo przechowywana w pliku, jest u nas dostêpna
jako warto¶æ zmiennej ¶rodowiskowej \texttt{TERMCAP}.
