% Impala Operating System
%
% Copyright (C) 2009 University of Wroclaw. Department of Computer Science
%    http://www.ii.uni.wroc.pl/
% Copyright (C) 2009 Mateusz Kocielski, Artur Koninski, Pawel Wieczorek
%    http://trzask.codepainters.com/impala/trac/
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
% 1. Redistributions of source code must retain the above copyright
%  notice, this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%  notice, this list of conditions and the following disclaimer in the
%  documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
% ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
% FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
% DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
% OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
% HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
% OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
% SUCH DAMAGE.
%
% $Id$


\section{Zarzadzanie pamiêci±.}
\label{VM}

Ten podrozdzia³ zawiera miêdzy innymi pobie¿ne opisy mechanizmów zwi±zanych
z~zarz±dzaniem pamiêci± w~systemie operacyjnym oraz techniczne ich aspekty.
O wiele bogatszy opis mo¿na znale¼æ w~pozycji \cite{silber}, a~dok³adne
omówienie aspektów technicznych w~\cite{intel}.

Komórki (bajty) pamiêci komputera s± adresowane 32 bitowymi liczbami\footnote{
Co daje $2^{32}$ ró¿nych adresów, czyli mo¿liwo¶æ zaadresowania 4GB pamiêci.},
adresy u¿ywane przez sprzêtow± jednostkê pamiêci nazywamy adresami fizycznymi, 
a adresy u¿ywane w~instrukcjach procesora adresami wirtualnymi. 

Pamiêæ wirtualna jest technik± umo¿liwiaj±c± tworzenie wielu wirtualnych
przestrzeni adresowych. W~tym celu wykorzystywany jest tak zwany mechanizm
stronicowania, realizowany przez procesor komputera. Stronicowanie polega
na~podziale pamiêci fizycznej na~bloczki o~ustalonym rozmiarze, zwane ramkami
\footnote{ramka - page frame}.
Pamiêæ wirtualna jest równie¿ podzielona na~takie bloczki, zwane stronami
\footnote{strona - page}.
Stronicowanie to przypisywanie stronom odpowiednich ramek, co mo¿na
zinterpretowaæ jako ustalaniem jaka ramka pamiêci fizycznej kryje siê za~dan±
stron± pamiêci wirtualnej. Adresy wirtualne z~instrukcji procesora s±
t³umaczone sprzêtowo na~adresy fizyczne.

Jest to~istotny element dla~wielozadaniowo¶ci poniewa¿ zwykle programy nie
wspó³dziel± pamiêci, a~pos³uguj± siê tymi samymi adresami. £atwo siê
o~tym przekonaæ pisz±c prosty program w~jêzyku C drukuj±cy na~ekran adres
jakiej¶ swojej zmiennej. Je¿eli uruchomimy jednocze¶nie wiele kopii naszego
programu to~ka¿dy wydrukuje ten sam adres, mimo ¿e~ka¿dy ma~swoj± w³asn±
pamiêæ.


Modu³ pamiêci wirtualnej jest podzielony na kilka warstw.
Najni¿sz± warstw± jest
\texttt{vm\_pmap} (\emph{page map}) odpowiedzialna za~obs³ugê odwzorowania stron
na~ramki; 
\texttt{vm\_seg} odpowiedzialna za~zarz±dzanie wirtualnymi segmentami;
\texttt{vm\_space} odpowiedzialna za~zarz±dzanie wirtualnymi przestrzeniami
adresowymi.

Obs³uga pamiêci wirtualnej powsta³a pod wp³ywem materia³ów 
omawiaj±cych zarz±dzanie pamiêci± wirtualn± w~systemach SVR4\footnote{
Jest to skrócona nazwa systemu jednej z~wersji systemu UNIX: 
,,System V: release 4''.}
i~Mach\cite{unixjadro}\footnote{
W dzisiejszych systemach operacyjnych pochodz±cych z~UNIXa mo¿na znale¼æ
nastêpców tych modulów: System Solaris wywodzi siê z systemu pi±tego, a pamiêæ
wirtualna systemu Mach przeniknê³a do~BSD.
} Nazewnictwo procedur by³o wzorowane na~drugi z~wymienionych modu³ów.


\subsection{Mapa pamiêci.}

Mapa pamiêci jest z~góry ustalona (rys \ref{vm:mmap}).
Dla programów u¿ytkownika
s± przeznaczone adresy poni¿ej 3GB, zwane ni¿szymi, a~dla j±dra adresy
powy¿ej, zwane wy¿szymi. Ka¿dy program wykonywany przez procesor wymaga
stosu oraz sterty. Stert± nazywamy segment dynamicznie przydzielanej
pamiêci przez program podczas dzia³ania.

Mapa pamiêci u¿ytkownika jest narzucona przez obs³ugiwany format plików
wykonywalnych A.out, omówiony w~\ref{tech:aout}. 
Stosy w±tków u¿ytkownika s± przydzielane
przez system na~koñcu jego przestrzeni adresowej. Ten sposób
postêpowania jest uzasadniony tym, ¿e sterta programu musi byæ ci±g³a
(z~punktu widzenia j±dra), a~nowe w±tki, wraz z~ich zapotrzebowaniem na~stos,
mog± przybywaæ podczas pracy programu.

Przestrzeñ j±dra wygl±da podobnie, na~ni± wp³yw wywar³ format ELF omówiony
w~\ref{tech:elf}. Z tych samych wzglêdów stosy w±tków j±dra oraz
stosy alternatywne w±tków u¿ytkownika s± umieszczane w koñcowych adresach.

Rozk³ad pamiêci fizycznej ró¿ni siê od przedstawionego (wirtualnego) powy¿ej.
Zawarto¶æ pamiêci w~adresach poni¿ej 1MB jest zwi±zana ze starszymi modelami
procesorów oraz BIOSem, st±d na rysunku pojawi³a siê nazwa BIOS. Miêdzy
innymi w~tej pamiêci jest odwzorowana pamiêæ karty graficznej, a system
operacyjny umieszcza tam bufory dla DMA\footnote{Direct Memory Access -
technologia pozwalaj±ca kopiowaæ dane miêdzy pamiêci± RAM a urz±dzeniem
przez szynê, bez udzia³u procesora. U¿ywanie DMA zwalnia programistê z~rêcznego
(udzia³ procesora) wysy³ania(odbierania) bajtów z(do)~urz±dzenia.} szyny
ISA, na której znajduje siê kontroler stacji dyskietek.


\begin{figure}
 \centering
 \includegraphics{work/vm_mmap}
 \caption{Mapa pamiêci a) wirtualnej, b) fizycznej. Strza³ki oznaczaj± w~któr±
stronê dany segment ro¶nie.}
 \label{vm:mmap}
\end{figure}


\subsection{Odwzorowania stron.}

Modu³ pamiêci wirtualnej opisuje ramki pamiêci za~pomoc± typu 
\texttt{vm\_page\_t}. Zawarte informacje to licznik odniesieñ, w~ilu
odwzorowaniach dana ramka siê znajduje, oraz adres fizyczny. 
Na wewnêtrzne potrzeby modu³u przy niektórych stronach zapisywana jest tak¿e
informacja o~adresie wirtualnym strony, w~jaki jest ta~ramka odwzorowana.

Opisy wszystkich ramek w komputerze s± umieszczone w~tablicy
\texttt{vm\_pages}. Je¿eli przy niektórych ramkach zosta³a zapisana
informacja o~adresie wirtualnym, to tablica mo¿e pos³u¿yæ te¿ jako
odwrotna tablica stron - tzn do t³umaczenia adresu fizycznego
na~adres wirtualny.

Przy rozruchu systemu
ka¿da ramka znajduj±ca siê za~j±drem jest wpinana w~listê wolnych ramek
\texttt{vm\_free\_pages}.

T³umaczenie adresów przez procesor odbywa siê w~dwóch etapach.
Pierwszy etap to~segmentacja, gdzie adresy z~instrukcji s± t³umaczone na~adresy
liniowe. Procesor podczas t³umaczenia korzysta z~tablicy deskryptorów, z~której
miêdzy innymi odczytuje informacje o~adresie bazowym i~d³ugo¶ci segmentu.
Adres liniowy powstaje poprzez przesuniêcie adresu z~instrukcji o~adres bazowy
danego segmentu\footnote{Sama segmentacja spe³nia jeszcze rolê ochronn±,
sprawdza czy program nie wyskoczy³ za~segment oraz czy ma odpowiednie prawa
dostêpu}. Ta~w³a¶ciwo¶æ nie jest wykorzystywana w~naszym systemie, dlatego
wszystkie adresy bazowe wynosz± 0, dziêki czemu adres liniowy jest to¿samy
z~adresem instrukcji\footnote{Popularne systemy takie jak FreeBSD, Linux,
Solaris równie¿ nie korzystaj± z tej w³a¶ciwo¶ci w~ogólnym zarz±dzaniu
pamiêci±, jedynie przy implementacji prywatnych segmentów dla w±tków
u¿ytkownika. Prawdopodobnie jest to~spowodowane tym, ¿e~jêzyk C nie wspiera
wykorzystania tego mechanizmu. Przesuniêcia spowodowa³oby ¿e~u¿ycie adresów
z~segmentu stosu na~kodzie operuj±cym na~segmencie danych by³oby nieprawid³owe.
St±d nie mo¿na by³oby u¿ywaæ np procedury \texttt{strlen} i~do~tablic bêd±cych
zmiennymi lokalnymi jak i~do~tablic bêd±cymi zmiennymi globalnymi. Wsparcie
wymaga³oby wprowadzenie nowego typu wska¼ników, w~których oprócz samego adresu
by³by zapisany deskryptor segmentu - stare kompilatory jêzyka C na~system DOS
w~tym celu rozszerza³y jêzyk  o~s³ówko kluczowe \texttt{far}.}.

Drugim etapem jest przet³umaczenie adresu na~adres fizyczny z~u¿yciem katalogu
stron. Sam katalog stron nie opisuje z~powodów technicznych wszystkich stron
w~pamiêci, poniewa¿ stron mo¿e byæ a¿ $2^{24}$ to~taki katalog zajmowa³by zbyt
du¿± ilo¶æ pamiêci (bior±c pod uwagê ¿e ka¿da przestrzeñ adresowa ma swój
katalog stron). Katalog zajmuje jedn± stronê pamiêci i~jest tablic± o~1024
elementach. Ka¿da pozycja w~katalogu zawiera adres fizyczny tablicy stron
opisuj±cej 4MB pamiêci. Poniewa¿ $1024*4MB=4GB$ to~katalog stron~opisujê ca³±
pamiêæ jak± mog± adresowaæ instrukcje procesora. Tablica stron ma tak± sam±
budowê jak katalog, z tym ¿e jej pozycje opisuj± fizyczne adresy
(zatem ka¿da pozycja tablicy stron opisuje 4kB pamiêci) ramek.

Procesor posiada rejestr kontrolny (CR3), w którym trzyma fizyczny adres
katalogu
stron. Ka¿da przestrzeñ adresowa posiada swój w³asny katalog stron, którego
adres jest wpisywany w ten rejestr przy zmianie kontekstu. Warstwa pamiêci
wirtualnej odpowiedzialna za~zarz±dzanie odwzorowaniami stron dla
ka¿dej ramki przydzielonej na~katalog lub stronê zapisuje jej adres wirtualny,
pod którym jest widziana w przestrzeni j±dra. Dziêki czemu operuj±c na katalogu
stron, w którym wska¼niki do tablic s± adresami fizycznymi, mo¿e szybko znale¼æ
prawid³owy adres wirtualny.

Odwzorowanie stron jest opisane przez typ
\texttt{vm\_pmap\_t}. Przed programist± systemu dwu stopniowa konstrukcja
katalogu jest ukryta, poniewa¿ nie jest to~istotne w~ogólnym zarz±dzaniu
pamiêci± oraz zrobi³oby modu³ mniej przeno¶nym\footnote{
Rozszerzenie procesora pozwalaj±ce u¿ywaæ 48bitowych adresów pamiêci
(zwiêkszaj±c ograniczenie pamiêci powy¿ej 4GB) wprowadza trój stopniow±
strukturê katalogu - dziêki ukryciu budowy zaprogramowanie obs³ugi
takiego rozszerzenia wi±za³oby siê z~mniejsza ilo¶ci± zmian w~kodzie.}.

Operacje na odwzorowaniu zarz±dzaj± licznikiem odniesieñ do ramki, odpowiednio
zwiêkszaj±c oraz zmniejszaj±c przy dodawaniu i~kasowaniu wpisów. Ramki
z~wyzerowanym licznikiem trafiaj± ponownie na listê wolnych ramek i~nadaj± siê
do~ponownego u¿ycia. Dodatkowymi operacjami s± rêczne t³umaczenie adresów
wirtualnych na~fizyczne oraz kopiowania stron pomiêdzy odwzorowaniami,
wykorzystywane przy wspó³dzieleniu pamiêci.

J±dro musi byæ odwzorowane w~ka¿dej przestrzeni adresowej, poniewa¿ w~ka¿dej
chwili musi znajdowaæ siê w pamiêci wirtualnej kod podprogramów obs³ugi
przerwañ oraz zleceñ od programu u¿ytkownika.

Odwzorowanie j±dra w~ka¿d± przestrzeñ adresow± wi±¿e siê z~dwoma trudno¶ciami
technicznymi. Pierwsza, czyszczenie pamiêci podrêcznej procesora,
przechowuj±cej fragmenty tablic stron, przy ka¿dej zmianie aktualnej
przestrzeni adresowej. Poniewa¿ kod j±dra jest w~ci±g³ym u¿yciu (zegar
systemowy oraz obs³uga programu) to~procesor bêdzie musia³ ¶ci±gnaæ
z~aktualnego katalogu i~tablic stron wpisy, które przed chwil± wykasowa³.
Druga trudno¶æ wynika z~posiadania w³asnego katalogu przez ka¿d± przestrzeñ.
Dodanie nowych tablic stron opisuj±cych pamiêæ j±dra wymaga edycji
wszystkich katalogów.

Pierwsza trudno¶æ zosta³a rozwi±zana sprzêtowo przez firmê Intel w~procesorach
Pentium Pro (i686) przez wprowadzenie specjalnego atrybutu GP\footnote{
Global Page - strona globalna.} informuj±cego procesor. ¿e dany wpis znajduje
siê we~wszystkich tablicach stron opisuj±cych te~same 4MB pamiêci.
Druga trudno¶æ zosta³a rozwi±zana przez przydzielenie wszystkich tablic stron
mog±cych opisywaæ przestrzeñ j±dra podczas rozruchu systemu. Dziêki temu
katalog stron ka¿dej nowo utworzonej przestrzeni zawiera wpisy ze~wszystkimi
tablicami jakie mo¿e u¿yæ j±dro i~nie wymaga pó¼niejszej edycji. Wad± tego
rozwi±zania jest to, ¿e j±dro mo¿e nigdy podczas swojej pracy nie u¿yæ
wszystkich tablic. Dla przestrzeni j±dra o~rozmiarze 1GB nale¿y przydzieliæ
256 tablic stron, co ³±cznie daje koszt 4MB.

\subsection{Wirtualne segmenty i przestrzenie adresowe.}

\begin{figure}
\centering
\includegraphics{work/vm_space}
\caption{Techniczne ujêcie przestrzeni adresowej.}
\label{vm:space}
\end{figure}

Wirtualna przestrzeñ adresowa jest dzielona na trzy wirtualne segmenty,
segment tekstu (kodu), danych (sterta i dane z~pliku) oraz stosów. Segmenty
danych i~stosu s± we wzajemnej relacji, poniewa¿ ich wzrost przybli¿a
koniec jednego do~pocz±tku drugiego, zatem system musi pilnowaæ momentu
w którym segmenty mog³yby siê spotkaæ - taki moment oznacza koniec pamiêci
dla programu.

Przestrzeñ adresowa jest opisywana przez typ \texttt{vm\_space\_t}, który
zawiera w~sobie odwzorowanie stron pamiêci oraz opisy trzech wy¿ej wspomnianych
segmentów.


Segment jest opisywany przez adres bazowy, aktualny rozmiar oraz ograniczenie
górne na~rozmiar. Przydzielanie i~niszczenie stosów podczas pracy programu
i~j±dra oraz odwzorowywanie ró¿nych fragmentów pamiêci w~stercie j±dra
i~niszczenie tych odwzorowañ 
powoduje fragmentacjê tych segmentów. Z~tego powodu
wirtualne segmenty nie musz± byæ ci±g³ymi przestrzeniami, lecz 
dynamicznie siê zmieniaj±cymi, obszarami. W~zwi±zku z~tym segment zawiera
w~sobie listê ci±g³ych obszarów, opisywanych przez typ \texttt{vm\_region\_t}.

Rysunek \ref{vm:space} przedstawia opis przestrzeni adresowej u¿ywany
w~module pamiêci wirtualnej.

\subsection{Sterta j±dra.}


