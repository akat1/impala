
#define _POSIX_C_SOURCE 200112L

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <ctype.h>

#include "mfs.h"

#define _is_print(c) (c != '\'' && c != '\\' && isprint(c))

typedef struct tar_header tar_header_t;

enum {
    TAR_MAX_NAME        = 100,
    TAR_MAX_MODE        = 8,
    TAR_MAX_UID         = 8,
    TAR_MAX_GID         = 8,
    TAR_MAX_SIZE        = 12,
    TAR_MAX_MTIME       = 12,
    TAR_MAX_CHKSUM      = 8,
    TAR_MAX_LINKNAME    = 100,
    TAR_MAX_USTAR       = 6,
    TAR_MAX_VERSION     = 2,
    TAR_MAX_UNAME       = 32,
    TAR_MAX_GNAME       = 32,
    TAR_MAX_DEVMAJOR    = 8,
    TAR_MAX_DEVMINOR    = 8,
    TAR_MAX_PREFIX      = 155,
    TAR_ALIGN           = 12,
    TAR_BSIZE           = 512
};

#define TAR_USTAR "ustar\0"
#define TAR_VERSION "00"
#define TAR_GNUTAR "ustar "
#define TAR_GNUVERSION "0\0"

struct tar_header {
    char    name0[TAR_MAX_NAME];
    char    mode[TAR_MAX_MODE];
    char    uid[TAR_MAX_UID];
    char    gid[TAR_MAX_GID];
    char    size[TAR_MAX_SIZE];
    char    mtime[TAR_MAX_MTIME];
    char    chksum[TAR_MAX_CHKSUM];
    char    type;
    char    linkname[TAR_MAX_LINKNAME];
    char    ustar[TAR_MAX_USTAR];
    char    version[TAR_MAX_VERSION];
    char    uname[TAR_MAX_UNAME];
    char    gname[TAR_MAX_GNAME];
    char    devmajor[TAR_MAX_DEVMAJOR];
    char    devminor[TAR_MAX_DEVMINOR];
    char    prefix[TAR_MAX_PREFIX];
    char    zero[TAR_ALIGN];
}; 

static void c_file_pre();
static void c_file_post();
static void c_file_put(unsigned char c);
static void output(unsigned char c);
static void output_str(const void *_b, size_t l);
static int is_zero(char *b);
static void convert();
static void usage();


static FILE *image, *cfile;
static FILE *input;
static char *symbol_name;
static char *input_name = NULL;
static int use_ctype = 0;

void
c_file_pre()
{
    fprintf(cfile, "/*\n");
    fprintf(cfile, " * File generated by Impala MFS util\n");
    fprintf(cfile, " * at %s %s\n", __TIME__, __DATE__);
    if (input_name)
        fprintf(cfile, " * from archive: %s\n", input_name);
    fprintf(cfile, " */\n");
    fprintf(cfile, "unsigned char %s[] = {\n", symbol_name);
}

void
c_file_post()
{
    fprintf(cfile, "\n};\n");
}


void
c_file_put(unsigned char c)
{
    enum {
        COL_MAX = 12
    };
    static int col = 0;
    if (col == 0) fprintf(cfile,"   ");
    if ( use_ctype && _is_print(c) ) {
        fprintf(cfile, "'%c' , ", c);
    } else {
        fprintf(cfile, "0x%02x, ", c);
    }
    col++;
    if (col == COL_MAX) {
        fprintf(cfile, "\n");
        col = 0;
    }
}

void
output(unsigned char c)
{
    if (symbol_name) c_file_put(c);
    if (image) assert( fwrite(&c, 1, 1, image) == 1);
}

void
output_str(const void *_b, size_t l)
{
    const char *b = (const char *)_b;
    while (l) {
        output(*b);
        l--;
        b++;
    }
}

int
is_zero(char *b)
{
    int i;
    for (i = 0; i < TAR_BSIZE; i++) {
        if (b[i] != 0)
              return 0;
    }
    return 1;
}




void
convert()
{
    char block[512];
    tar_header_t *thdr;
    mfs_data_entry_t de;

    while (!feof(input)) //
    if (fread(block, TAR_BSIZE, 1, input) == 1) {

            thdr = (tar_header_t*) block;
            if (is_zero(block)) {
                continue;
            }
            thdr->ustar[5] = 0;
            assert( memcmp(thdr->ustar, TAR_USTAR, TAR_MAX_USTAR) == 0);
            thdr->size[TAR_MAX_SIZE-1] = 0;

            snprintf(de.name, MFS_MAX_FILENAME, "%.100s%.155s", thdr->name0,
                thdr->prefix);
            de.name[MFS_MAX_FILENAME-1] = 0;
            de.size = strtol(thdr->size, NULL, 8);
            assert( thdr->type == '0' || thdr->type == '5' );
            if (thdr->type == '0') {
                de.type = MFS_TYPE_REG;
            } else {
                de.type = MFS_TYPE_DIR;
            }
            de.attr = 0777;
            output_str(&de, sizeof(de));
            if (de.size > 0) {
                int i;
                for (i = 0; i < (de.size)/TAR_BSIZE; i++) {
                    assert(fread(block, TAR_BSIZE, 1, input) == 1);
                    output_str(block, TAR_BSIZE);
                }
                assert(fread(block, TAR_BSIZE, 1, input) == 1);
                output_str(block, de.size % TAR_BSIZE);
            }
    }
    
}

void
usage()
{
    printf("Impala MFS util\n");
    printf("usage: mfsutil [-i <img>] [-s <symbol> -c <cfile>] -t [-f tar]\n");
    printf("    -i <img>        output image file name\n");
    printf("    -s <symbol>     C source symbol name\n");
    printf("    -c <cfile>      C source file name\n");
    printf("    -t              show characters instead of numbers\n");
    printf("    -f <tar>        input USTAR archive file name\n");
    printf("default input is stdin\n");
}

int
main(int argc, char **argv)
{
    char ch;
    image = NULL;
    cfile = NULL;
    symbol_name = NULL;
    input = stdin;
    while ( (ch = getopt(argc, argv, "i:c:hs:tf:")) != -1)
    switch (ch) {
        case 'i':
            image = fopen(optarg, "w");
            assert(image != NULL);
            break;
        case 'c':
            cfile = fopen(optarg, "w");
            assert(cfile != NULL);
            break;
        case 's':
            symbol_name = optarg;
            break;
        case 'f':
            input = fopen(optarg,"r");
            input_name = optarg;
            assert(input != NULL);
            break;
        case 't':
            use_ctype = 1;
            break;
        case 'h':
            usage();
            return 0;
        default:
            printf("Bad usage\n");
            return -1;
            break;
    }
    if ( !(cfile && symbol_name) && (cfile || symbol_name)) {
        printf("cfile and symbolname have to be defined both!\n");
        return -1;
    }
    if (symbol_name) c_file_pre();
    convert();
    if (symbol_name) c_file_post();
    return 0;
}
